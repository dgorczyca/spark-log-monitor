// node_modules/@github/spark/dist/kv-WMiiBMWU.js
var KvEventType = {
  SPARK_KV_UPDATED: "sparkKvUpdated",
  SPARK_KV_DELETED: "sparkKvDeleted"
};
var sendEventToWorkbench = (message) => {
  if (import.meta.env.DEV) {
    window.parent.postMessage(message, "*");
  }
};
var KVClient = class {
  /**
  * Retrieves a list of all keys in the KV store.
  * @returns A list of all keys in the KV store, or an empty array if there are no keys.
  */
  async getKeys() {
    const response = await fetch(BASE_KV_SERVICE_URL, {
      method: "GET"
    });
    if (!response.ok) {
      const errorMessage = `Failed to fetch KV keys: ${response.statusText}`;
      return Promise.reject(new Error(errorMessage));
    }
    let json;
    try {
      json = await response.json();
    } catch (error) {
      const errorMessage = "Failed to parse KV keys response";
      return Promise.reject(new Error(errorMessage));
    }
    if (!Array.isArray(json)) {
      const errorMessage = "KV keys response is not an array";
      return Promise.reject(new Error(errorMessage));
    }
    return json;
  }
  /**
   * Retrieves all key-value pairs from the KV store.
   * @returns An object containing all key-value pairs, or an empty object if there are no keys.
   *
   * TODO: replace with batch request
   */
  async getAll() {
    const keys = await this.getKeys();
    const result = {};
    const values = await Promise.all(keys.map((key) => this.getKey(key)));
    keys.forEach((key, index) => {
      const value = values[index];
      if (value !== void 0) {
        result[key] = value;
      }
    });
    return result;
  }
  /**
   * Retrieves the value associated with the given key from the KV store.
   * @param key The key to retrieve.
   * @returns The value associated with the key, or undefined if not found.
   */
  async getKey(key) {
    const response = await fetch(`${BASE_KV_SERVICE_URL}/${encodeURIComponent(key)}`, {
      method: "GET",
      headers: {
        "Content-Type": `text/plain`
      }
    });
    if (!response.ok) {
      const errorMessage = `Failed to fetch KV key: ${response.statusText}`;
      if (response.status === 404) {
        return void 0;
      }
      return Promise.reject(new Error(errorMessage));
    }
    const responseText = await response.text();
    try {
      return JSON.parse(responseText);
    } catch (error) {
      const errorMessage = `Failed to parse KV key response`;
      return Promise.reject(new Error(errorMessage));
    }
  }
  /**
   * Retrieves the value associated with the given key from the KV store, while also setting it if it does not exist.
   * @param key The key to retrieve.
   * @param value The value to set if the key does not exist.
   * @returns The value associated with the key, whether it was retrieved or newly set.
   */
  async getOrSetKey(key, value) {
    const existingValue = await this.getKey(key);
    if (existingValue !== void 0) {
      return existingValue;
    }
    const response = await fetch(`${BASE_KV_SERVICE_URL}/${encodeURIComponent(key)}`, {
      method: "POST",
      headers: {
        "Content-Type": `text/plain`,
        "X-Spark-Initial": "true"
      },
      body: JSON.stringify(value)
    });
    if (!response.ok) {
      const errorMessage = `Failed to set default value for key: ${response.statusText}`;
      return Promise.reject(new Error(errorMessage));
    }
    sendEventToWorkbench({
      type: KvEventType.SPARK_KV_UPDATED,
      payload: { key }
    });
    return value;
  }
  /**
   * Sets the value for the given key in the KV store.
   * @param key The key to set.
   * @param value The value to associate with the key.
   * @returns A promise that resolves when the operation is complete.
   */
  async setKey(key, value) {
    const response = await fetch(`${BASE_KV_SERVICE_URL}/${encodeURIComponent(key)}`, {
      method: "POST",
      headers: {
        "Content-Type": `text/plain`,
        "X-Spark-Initial": "false"
      },
      body: JSON.stringify(value)
    });
    if (!response.ok) {
      const errorMessage = `Failed to set key: ${response.statusText}`;
      return Promise.reject(new Error(errorMessage));
    }
    sendEventToWorkbench({
      type: KvEventType.SPARK_KV_UPDATED,
      payload: { key, value: JSON.stringify(value) }
    });
  }
  /**
   * Deletes the value associated with the given key from the KV store.
   * @param key The key to delete from the KV store.
   */
  async deleteKey(key) {
    await fetch(`${BASE_KV_SERVICE_URL}/${encodeURIComponent(key)}`, { method: "DELETE" });
    sendEventToWorkbench({
      type: KvEventType.SPARK_KV_DELETED,
      payload: { key }
    });
  }
};

export {
  KvEventType,
  KVClient
};
//# sourceMappingURL=chunk-2T664JH7.js.map
